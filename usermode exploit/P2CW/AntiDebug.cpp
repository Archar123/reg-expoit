#include "AntiDebug.h"
#include "Macro.hpp"
#include "ThemidaSDK.h"
//#include "xor.h"

/*
GITHUB USED FOR ANTI DEBUG: https://github.com/LordNoteworthy/al-khaser/tree/master/al-khaser/Anti%20Debug
*/



BOOL bIsBeinDbg = TRUE;

LONG WINAPI UnhandledExcepFilter(PEXCEPTION_POINTERS pExcepPointers)
{
	// If a debugger is present, then this function will not be reached.
	bIsBeinDbg = FALSE;
	return EXCEPTION_CONTINUE_EXECUTION;
}

EXCEPTION_DISPOSITION ExceptionRoutine(
	PEXCEPTION_RECORD ExceptionRecord,
	PVOID             EstablisherFrame,
	PCONTEXT          ContextRecord,
	PVOID             DispatcherContext)
{
	if (EXCEPTION_INVALID_HANDLE == ExceptionRecord->ExceptionCode)
	{
		exit(-1);
	}
	return ExceptionContinueExecution;
}
HANDLE hThread;
namespace AntiDebug
{
	/*
	This is another Win32 Debugging API function; it can be used to check if a remote process is being debugged,
	However, we can also use this for checking if our own process is being debugged. it calls the NTDLL export
	NtQueryInformationProcess with the SYSTEM_INFORMATION_CLASS set to 7 (ProcessDebugPort).
	*/
	__declspec (noinline)  BOOL CheckRemoteDebuggerPresentAPI()
	{
		MUTATE_START
		BOOL bCheckRemoteDebuggerPresent = FALSE;
		imp(CheckRemoteDebuggerPresent).cached()(imp(GetCurrentProcess).cached()(), &bCheckRemoteDebuggerPresent);
		return bCheckRemoteDebuggerPresent;
		MUTATE_END
	}

	__declspec (noinline)  BOOL HideThread()
	{
		MUTATE_START
		typedef NTSTATUS(NTAPI* pNtSetInformationThread)
			(HANDLE, UINT, PVOID, ULONG);
		NTSTATUS Status;

		// Get NtSetInformationThread
		pNtSetInformationThread NtSIT = (pNtSetInformationThread)
			imp(GetProcAddress).cached()(GetModuleHandle(TEXT(st("ntdll.dll"))),
				st("NtSetInformationThread"));

		// Shouldn't fail
		if (NtSIT == NULL)
			return false;

		// Set the thread info
		if (hThread == NULL)
			Status = NtSIT(imp(GetCurrentThread).cached()(),
				0x11, // HideThreadFromDebugger
				0, 0);
		else
			Status = NtSIT(hThread, 0x11, 0, 0);

		if (Status != 0x00000000)
			return false;
		else
			return true;
		MUTATE_END
	}

	/*
	This function is part of the Win32 Debugging API
	It determines whether the calling process is being debugged by a user-mode debugger.
	If the current process is running in the context of a debugger, the return value is nonzero.
	*/
	__declspec (noinline)  BOOL IsDebuggerPresentAPI()
	{
		MUTATE_START
		if (imp(IsDebuggerPresent).cached()())
			return TRUE;
		else
			return FALSE;
		MUTATE_END
	}

	/*
	Hardware breakpoints are a technology implemented by Intel in their processor architecture,
	and are controlled by the use of special registers known as Dr0-Dr7.
	Dr0 through Dr3 are 32 bit registers that hold the address of the breakpoint .
	*/
	__declspec (noinline)  BOOL HardwareBreakpoints()
	{
		MUTATE_START
		PCONTEXT ctx = PCONTEXT(imp(VirtualAlloc).cached()(NULL, sizeof(ctx), MEM_COMMIT, PAGE_READWRITE));
		SecureZeroMemory(ctx, sizeof(CONTEXT));

		ctx->ContextFlags = CONTEXT_DEBUG_REGISTERS;

		if (GetThreadContext(GetCurrentThread(), ctx) == 0)
			return -1;


		if (ctx->Dr0 != 0 || ctx->Dr1 != 0 || ctx->Dr2 != 0 || ctx->Dr3 != 0)
			return TRUE;
		else
			return FALSE;
		MUTATE_END
	}

	/*
	Calling NtSetInformationThread will attempt with ThreadInformationClass set to  x11 (ThreadHideFromDebugger)
	to hide a thread from the debugger, Passing NULL for hThread will cause the function to hide the thread the
	function is running in. Also, the function returns false on failure and true on success. When  the  function
	is called, the thread will continue  to run but a debugger will no longer receive any events related to that thread.
	These checks also look for hooks on the NtSetInformationThread API that try to block ThreadHideFromDebugger.
	*/


	/*
	In essence, what occurs is that we allocate a dynamic buffer and write a RET to the buffer.
	We then mark the page as a guard page and push a potential return address onto the stack. Next, we jump to our page,
	and if we're under a debugger, specifically OllyDBG, then we will hit the RET instruction and return to the address we pushed onto
	the stack before we jumped to our page. Otherwise, a STATUS_GUARD_PAGE_VIOLATION exception will occur, and we know we're not being
	debugged by OllyDBG.
	*/
	__declspec (noinline)  BOOL MemoryBreakpoints_PageGuard()
	{
		
		UCHAR* pMem = NULL;
		SYSTEM_INFO SystemInfo = { 0 };
		DWORD OldProtect = 0;
		PVOID pAllocation = NULL; // Get the page size for the system 

								  // Retrieves information about the current system.
		imp(GetSystemInfo).cached()(&SystemInfo);

		// Allocate memory 
		pAllocation = imp(VirtualAlloc).cached()(NULL, SystemInfo.dwPageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (pAllocation == NULL)
			return FALSE;

		// Write a ret to the buffer (opcode 0xc3)
		RtlFillMemory(pAllocation, 1, 0xC3);

		// Make the page a guard page         
		if (imp(VirtualProtect).cached()(pAllocation, SystemInfo.dwPageSize, PAGE_EXECUTE_READWRITE | PAGE_GUARD, &OldProtect) == 0)
			return FALSE;

		__try
		{
			((void(*)())pAllocation)(); // Exception or execution, which shall it be :D?
		}
		__except (GetExceptionCode() == STATUS_GUARD_PAGE_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
		{
			imp(VirtualFree).cached()(pAllocation, NULL, MEM_RELEASE);
			return FALSE;
		}

		imp(VirtualFree).cached()(pAllocation, NULL, MEM_RELEASE);
		return TRUE;
		
	}

	/*
	This check works by asking for the addresses of a whole load of APIs from a library, then checking that the resulting pointer is within that library's memory addrress space.
	Note that this is an incomplete set of APIs on purpose. Some APIs are redirected to alternative implementations on Windows 10, and those APIs have been omitted.
	*/
	/*inline BOOL ModuleBoundsHookCheck()
	{
		bool foundHook = ModuleBoundsHookCheckSingle(LoadLibrary(_T("kernel32.dll")), apis_kernel32) &&
			ModuleBoundsHookCheckSingle(LoadLibrary(_T("ntdll.dll")), apis_ntdll) &&
			ModuleBoundsHookCheckSingle(LoadLibrary(_T("user32.dll")), apis_user32);

		return foundHook ? TRUE : FALSE;
	}*/

	/*
	When an exception occurs, and no registered Exception Handlers exist (neither Structured nor
	Vectored), or if none of the registered handlers handles the exception, then the kernel32
	UnhandledExceptionFilter() function will be called as a last resort.
	*/
	__declspec (noinline)  BOOL UnhandledExcepFilterTest()
	{
		MUTATE_START
		LPTOP_LEVEL_EXCEPTION_FILTER Top = imp(SetUnhandledExceptionFilter).cached()(imp(UnhandledExcepFilter).cached());
		imp(RaiseException).cached()(EXCEPTION_FLT_DIVIDE_BY_ZERO, 0, 0, NULL);
		imp(SetUnhandledExceptionFilter).cached()(Top);
		return bIsBeinDbg;
		MUTATE_END
	}

	/*
	NtQuerySystemInformation can be used to detect the presence of a kernel debugger. However, the
	same information can be obtained from user mode with no system calls at all. This is done by
	reading from the KUSER_SHARED_DATA struct, which is has a fixed user mode address of 0x7FFE0000 in all versions
	of Windows in both 32 and 64 bit. In kernel mode it is located at 0xFFDF0000 (32 bit) or 0xFFFFF78000000000 (64 bit).
	Detailed information about KUSER_SHARED_DATA can be found here: http://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/kuser_shared_data.htm
	*/
	__declspec (noinline)  BOOL SharedUserData_KernelDebugger()
	{
		MUTATE_START
		// The fixed user mode address of KUSER_SHARED_DATA
		const ULONG_PTR UserSharedData = 0x7FFE0000;

		// UserSharedData->KdDebuggerEnabled is a BOOLEAN according to ntddk.h, which gives the false impression that it is
		// either true or false. However, this field is actually a set of bit flags, and is only zero if no debugger is present.
		const UCHAR KdDebuggerEnabledByte = *(UCHAR*)(UserSharedData + 0x2D4); // 0x2D4 = the offset of the field

																			   // Extract the flags.
																			   // The meaning of these is the same as in NtQuerySystemInformation(SystemKernelDebuggerInformation).
																			   // Normally if a debugger is attached, KdDebuggerEnabled is true, KdDebuggerNotPresent is false and the byte is 0x3.
		const BOOLEAN KdDebuggerEnabled = (KdDebuggerEnabledByte & 0x1) == 0x1;
		const BOOLEAN KdDebuggerNotPresent = (KdDebuggerEnabledByte & 0x2) == 0;

		if (KdDebuggerEnabled || !KdDebuggerNotPresent)
			return TRUE;

		return FALSE;
		MUTATE_END
	}

	__declspec (noinline)  BOOL IsSystemCodeIntegrityEnabled()
	{

		MUTATE_START
		typedef NTSTATUS(__stdcall* td_NtQuerySystemInformation)(
			ULONG           SystemInformationClass,
			PVOID           SystemInformation,
			ULONG           SystemInformationLength,
			PULONG          ReturnLength
			);

		struct SYSTEM_CODEINTEGRITY_INFORMATION {
			ULONG Length;
			ULONG CodeIntegrityOptions;
		};

		static td_NtQuerySystemInformation NtQuerySystemInformation = (td_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA(st("ntdll.dll")), st("NtQuerySystemInformation"));

		SYSTEM_CODEINTEGRITY_INFORMATION Integrity = { sizeof(SYSTEM_CODEINTEGRITY_INFORMATION), 0 };
		NTSTATUS status = NtQuerySystemInformation(103, &Integrity, sizeof(Integrity), NULL);

		return (status && (Integrity.CodeIntegrityOptions & 1));

		MUTATE_END
	}


	/*inline BOOL IsVM()
	{
		HKEY hKey;
		int i;
		char szBuffer[64];
		const char* szProducts[] = { "*VMWARE*", "*VBOX*", "*VIRTUAL*" };

		DWORD dwSize = sizeof(szBuffer) - 1;

		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, ("SYSTEM\\ControlSet001\\Services\\Disk\\Enum"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
		{
			if (RegQueryValueEx(hKey, "0", NULL, NULL, (unsigned char*)szBuffer, &dwSize) == ERROR_SUCCESS)
			{
				for (i = 0; i < _countof(szProducts); i++)
				{
					if (strstr(szBuffer, szProducts[i]))
					{
						RegCloseKey(hKey);
						return TRUE;
					}
				}
			}

			RegCloseKey(hKey);
		}

		return FALSE;
	}

	inline BOOL IsSandboxie()
	{
		if (GetModuleHandle(("SbieDll.dll")) != NULL)
			return TRUE;


		return FALSE;
	}

	inline BOOL IsVirtualBox()
	{
		BOOL bDetected = FALSE;

		if (LoadLibrary(("VBoxHook.dll")) != NULL)
			bDetected = TRUE;

		if (CreateFile(("\\\\.\\VBoxMiniRdrDN"), GENERIC_READ, \
			FILE_SHARE_READ, NULL, OPEN_EXISTING, \
			FILE_ATTRIBUTE_NORMAL, NULL) \
			!= INVALID_HANDLE_VALUE)
		{
			bDetected = TRUE;
		}

		return bDetected;
	}*/
}
// developed by l3g2nd
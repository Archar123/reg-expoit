#pragma once
#include <Windows.h>
#include <intrin.h>
#include <stdio.h>
#pragma intrinsic(_ReturnAddress)


__declspec (noinline)  void ErasePEHeaderFromMemory()
{
    MUTATE_START
    DWORD OldProtect = 0x1000;

    // Get base address of module
    char* pBaseAddr = (char*)GetModuleHandle(NULL);

    // Change memory protection
    imp(VirtualProtect).cached()(pBaseAddr, 4096, // Assume x86 page size
        PAGE_READWRITE, &OldProtect);

    // Erase the header
    ZeroMemory(pBaseAddr, 4096);
    MUTATE_END
}

__declspec (noinline) void foo()
{
    // ...
    MUTATE_START
    PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (imp(VirtualProtect).cached()(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            imp(VirtualProtect).cached()(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
    MUTATE_END
    // ...
}

__declspec (noinline) BOOL isDebuggerPresent()
{
    MUTATE_START
    BOOL result = FALSE;
    HINSTANCE kern_lib = LoadLibraryEx(st("kernel32.dll"), NULL, 0);
    if (kern_lib) {
        FARPROC lIsDebuggerPresent = GetProcAddress(kern_lib, st("IsDebuggerPresent"));
        if (lIsDebuggerPresent && lIsDebuggerPresent()) {
            result = TRUE;
        }
        FreeLibrary(kern_lib);
    }
    return result;
    MUTATE_END
}


__declspec (noinline) bool MemoryBreakpointDebuggerCheck()
{
    MUTATE_START
    unsigned char* pMem = NULL;
    SYSTEM_INFO sysinfo = { 0 };
    DWORD OldProtect = 0;
    void* pAllocation = NULL; // Get the page size for the system 

    imp(GetSystemInfo).cached()(&sysinfo); // Allocate memory 

    pAllocation = VirtualAlloc(NULL, sysinfo.dwPageSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    if (pAllocation == NULL)
        return false;

    // Write a ret to the buffer (opcode 0xc3)
    pMem = (unsigned char*)pAllocation;
    *pMem = 0xc3;

    // Make the page a guard page         
    if (imp(VirtualProtect).cached()(pAllocation, sysinfo.dwPageSize,
        PAGE_EXECUTE_READWRITE | PAGE_GUARD,
        &OldProtect) == 0)
    {
        return false;
    }

    __try
    {

        {

        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        // The exception occured and no debugger was detected
        imp(VirtualFree).cached()(pAllocation, NULL, MEM_RELEASE);
        return false;
    }


    imp(VirtualFree).cached()(pAllocation, NULL, MEM_RELEASE);
    return true;
    MUTATE_END
}

